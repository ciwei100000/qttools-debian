From 2203d8c3b1ff76cbc1e9341506d15d3e5535d41b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kai=20K=C3=B6hne?= <kai.koehne@qt.io>
Date: Fri, 5 Mar 2021 10:35:04 +0100
Subject: [PATCH] Fix regression in lconvert handling empty translations

Fixes a regression introduced by commit b96fe95da00aca6b, which enabled
a sanity check that now failed to account for empty string.

The serialized format of a QString is such that '-1' indicates a null
string, otherwise it's <length><QChar>+. Since QChar is 2 bytes,
length should therefore always be an even number ... except for -1.

While at it, also preserve the difference between an empty string and
a null string.

Fixes: QTBUG-91558
Pick-to: 6.1
Change-Id: Iffbc6ee2c94b8363d2c1d91440022a77dbef4772
Reviewed-by: Joerg Bornemann <joerg.bornemann@qt.io>
(cherry picked from commit b9a9f7b502f0631144176be343779a698e54161e)
---
 src/linguist/shared/qm.cpp                        |  11 ++++++++---
 tests/auto/linguist/lconvert/data/untranslated.qm | Bin 0 -> 222 bytes
 tests/auto/linguist/lconvert/tst_lconvert.cpp     |   2 ++
 3 files changed, 10 insertions(+), 3 deletions(-)
 create mode 100644 tests/auto/linguist/lconvert/data/untranslated.qm

diff --git a/src/linguist/shared/qm.cpp b/src/linguist/shared/qm.cpp
index 71e2a832..60689178 100644
--- a/src/linguist/shared/qm.cpp
+++ b/src/linguist/shared/qm.cpp
@@ -552,12 +552,17 @@ bool loadQM(Translator &translator, QIODevice &dev, ConversionData &cd)
                 goto end;
             case Tag_Translation: {
                 int len = read32(m);
-                if (len & 1) {
+                m += 4;
+
+                // -1 indicates an empty string
+                // Otherwise streaming format is UTF-16 -> 2 bytes per character
+                if ((len != -1) && (len & 1)) {
                     cd.appendError(QLatin1String("QM-Format error"));
                     return false;
                 }
-                m += 4;
-                QString str = QString((const QChar *)m, len/2);
+                QString str;
+                if (len != -1)
+                    str = QString((const QChar *)m, len / 2);
                 if (QSysInfo::ByteOrder == QSysInfo::LittleEndian) {
                     for (int i = 0; i < str.length(); ++i)
                         str[i] = QChar((str.at(i).unicode() >> 8) +

diff --git a/tests/auto/linguist/lconvert/tst_lconvert.cpp b/tests/auto/linguist/lconvert/tst_lconvert.cpp
index 2b3729d6..7ddfd5c0 100644
--- a/tests/auto/linguist/lconvert/tst_lconvert.cpp
+++ b/tests/auto/linguist/lconvert/tst_lconvert.cpp
@@ -282,6 +282,7 @@ void tst_lconvert::roundtrips_data()
     QStringList tsPoTs; tsPoTs << "ts" << "po" << "ts";
     QStringList tsXlfTs; tsXlfTs << "ts" << "xlf" << "ts";
     QStringList tsQmTs; tsQmTs << "ts" << "qm" << "ts";
+    QStringList qmTsQm; qmTsQm << "qm" << "ts" << "qm";
 
     QList<QStringList> noArgs;
     QList<QStringList> filterPoArgs; filterPoArgs << QStringList() << (QStringList() << "-drop-tag" << "po:*");
@@ -318,6 +319,7 @@ void tst_lconvert::roundtrips_data()
 
     QTest::newRow("ts-po-ts (endless loop)") << "endless-po-loop.ts" << tsPoTs << noArgs;
     QTest::newRow("ts-qm-ts (whitespace)") << "whitespace.ts" << tsQmTs << noArgs;
+    QTest::newRow("qm-ts-qm (untranslated)") << "untranslated.qm" << qmTsQm << noArgs;
 }
 
 void tst_lconvert::roundtrips()
-- 
2.31.1.windows.1

